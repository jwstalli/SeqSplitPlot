---
title: "ST 695 Sequential Split Plot Designs"
output: word_document
date: "2025-05-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This code chunk produces a design matrix for a split plot design given the number of HTC Factors (HTC), Easy to Change Factors (ETC), and replicates for HTC Factors 
```{r }

HTC <- 2
ETC <- 2
r <- 2

# Create the factors for the Design Matrix
w_names <- paste0("w", 1:HTC)
s_names <- paste0("s", 1:ETC)

# Create list of w and s variables
combined_list <- c(
  setNames(replicate(HTC, c(-1, 1), simplify = FALSE), w_names),
  setNames(replicate(ETC, c(-1, 1), simplify = FALSE), s_names)
)

# Create data frame of all combinations of w and s
df <- expand.grid(combined_list) #base experimental design
df_rep <- df[rep(seq_len(nrow(df)), r), ] #replicated experimental design
row.names(df_rep) <- NULL #make the row count sequential

# Build the formula for linear and interaction terms (no quadratic)
linear_terms <- c(w_names, s_names)
fo <- as.formula(
  paste("~ (", paste(linear_terms, collapse = " + "), ")^2")
)

# Create the model matrix
X <- model.matrix(fo, data = df_rep)
colnames(X)[1] <- '0'

```


Simulate response data by specifying $\beta_r, \beta_{rs}, \sigma^2_B, \sigma^2$.
The inputs to the simulation are Beta, sigma2_B, sigma2
```{r}

set.seed(1)
  N <- r * 2^HTC # Number of Whole Plots
  M <- 2^ETC #Number of Runs per Whole Plot
  q <- ncol(X) # Number of Main Effects and Interaction Effects
  n <- r * 2^HTC * 2^ETC
  nsim <- 100  #Number of Simulation Runs

  fixed_effect_names <- paste0("beta", colnames(X))
  
  beta <- setNames(rnorm(q), fixed_effect_names)  #assign values to fixed effect names
  sigma2 <- 1  #assign value to sigma squared
  sigma2_B <- 1 #assign value to sigma squared B

#Simulation Function  
sim_data <- function(X, beta) {
  mu <- matrix(0, nrow = N, ncol= M)
  delta <- vector()
  epsilon <- matrix(0, N, M)
  
      
        for (i in 1:N) {
        delta[i] <- rnorm(1, mean = 0, sd = sqrt(sigma2_B))
        
        for (j in 1:M) { 
        epsilon[i,j] <- rnorm(1, mean = 0, sd = sqrt(sigma2))
        
        # Linear Terms
        for (r in 1:q) {
        mu[i,j] <- mu[i,j] + X[i,r] * beta[r] 
        }
        mu[i,j] <- mu[i,j] + delta[i] + epsilon [i,j]
      }
    }
    return(mu)
  }

Y <- matrix(0, nrow = n , ncol = nsim )
for (i in 1:nsim) {
    Y[,i] <- sim_data(X, beta)
    }

```

Simulation Summary Results
```{r}

colnames(Y) <- c(rep(paste0("Y",1:nsim)))
summary.matrix(Y)


```